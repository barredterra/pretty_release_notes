import threading
import time

from requests import HTTPError

from core.config import ReleaseNotesConfig
from core.interfaces import NullProgressReporter, ProgressEvent, ProgressReporter
from database import get_db
from github_client import GitHubClient
from models import ReleaseNotes, ReleaseNotesLine, Repository
from openai_client import get_chat_response


class ReleaseNotesGenerator:
	def __init__(
		self,
		config: ReleaseNotesConfig,
		progress_reporter: ProgressReporter | None = None,
	):
		self.config = config
		self.github = GitHubClient(config.github.token)
		self.repository = None
		self.progress = progress_reporter or NullProgressReporter()

		# Store config values for easy access
		self.exclude_change_types = config.filters.exclude_change_types
		self.exclude_change_labels = config.filters.exclude_change_labels
		self.exclude_authors = config.filters.exclude_authors
		self.openai_api_key = config.openai.api_key
		self.openai_model = config.openai.model
		self.max_patch_size = config.openai.max_patch_size
		self.prompt_path = config.prompt_path
		self.db_type = config.database.type
		self.db_name = config.database.name
		self.use_db = config.database.enabled
		self.force_use_commits = config.force_use_commits

	def initialize_repository(self, owner: str, name: str):
		self.repository = self.github.get_repository(owner, name)

	def generate(self, tag: str):
		"""Generate release notes for a given tag."""
		release = self._get_release(tag)
		old_body = release["body"]

		self.progress.report(
			ProgressEvent(
				type="release_notes",
				message=old_body,
				metadata={"heading": "Current Release Notes"},
			)
		)

		try:
			gh_notes = self.github.generate_release_notes(self.repository, tag)
			new_body = gh_notes["body"]
			self.progress.report(
				ProgressEvent(
					type="release_notes",
					message=new_body,
					metadata={"heading": "Regenerated by GitHub"},
				)
			)
		except HTTPError as e:
			if e.response.status_code != 403:
				raise e

			self.progress.report(
				ProgressEvent(
					type="error",
					message="No permission to regenerate release notes, trying to proceed with old ones.",
				)
			)
			new_body = old_body

		self.progress.report(ProgressEvent(type="markdown", message="# Rewriting ..."))

		release_notes = ReleaseNotes.from_string(new_body)
		pr_start_time = time.time()
		self._get_prs_for_lines(release_notes.lines)
		pr_end_time = time.time()
		self.progress.report(
			ProgressEvent(
				type="success",
				message=f"Downloaded PRs in {pr_end_time - pr_start_time:.2f} seconds.",
			)
		)

		if self.force_use_commits or (
			not any(line.change for line in release_notes.lines)
			and "Full Changelog" in gh_notes["body"]
		):
			prev_tag = get_prev_tag(gh_notes["body"], self.repository)
			release_notes.lines = (
				self._get_commit_lines(tag, prev_tag) + release_notes.lines
			)

		process_start_time = time.time()
		self._process_lines(release_notes.lines)
		process_end_time = time.time()
		self.progress.report(
			ProgressEvent(
				type="success",
				message=f"Processed lines in {process_end_time - process_start_time:.2f} seconds.",
			)
		)

		reviewers_start_time = time.time()
		release_notes.load_reviewers()
		reviewers_end_time = time.time()
		self.progress.report(
			ProgressEvent(
				type="success",
				message=f"Loaded reviewers in {reviewers_end_time - reviewers_start_time:.2f} seconds.",
			)
		)

		return release_notes.serialize(
			self.exclude_change_types,
			self.exclude_change_labels,
			self.exclude_authors,
			model_name=f"OpenAI {self.openai_model}",
		)

	def _get_prs_for_lines(self, lines: list["ReleaseNotesLine"]):
		"""Download info for all PRs in parallel."""
		threads = []
		for line in lines:
			thread = threading.Thread(target=self._get_pr_for_line, args=(line,))
			threads.append(thread)
			thread.start()
		for thread in threads:
			thread.join()

	def _get_pr_for_line(self, line: "ReleaseNotesLine"):
		"""Download info for a single PR."""
		if line.pr_no and not line.is_new_contributor:
			line.change = self.github.get_pr(self.repository, line.pr_no)

	def _process_lines(self, lines: list["ReleaseNotesLine"]):
		"""Process all lines in parallel."""
		threads = []
		for line in lines:
			thread = threading.Thread(target=self._process_line, args=(line,))
			threads.append(thread)
			thread.start()
		for thread in threads:
			thread.join()

	def update_on_github(self, new_body: str, tag: str):
		"""Update release notes on GitHub."""
		release = self._get_release(tag)
		try:
			self.github.update_release(self.repository, release["id"], new_body)
			self.progress.report(
				ProgressEvent(
					type="success", message="Release notes updated successfully."
				)
			)
		except HTTPError as e:
			if e.response.status_code != 403:
				raise e

			self.progress.report(
				ProgressEvent(
					type="error",
					message="No permission to update release notes, skipping.",
				)
			)

	def _get_commit_lines(self, tag: str, prev_tag: str | None = None):
		if prev_tag:
			commits = self.github.get_diff_commits(self.repository, tag, prev_tag)
		else:
			commits = self.github.get_tag_commits(self.repository, tag)

		return (
			[
				# Add the same heading line for the commits, that is automatically added by GitHub for PRs
				ReleaseNotesLine(
					original_line="## What's Changed",
				)
			]
			+ [
				ReleaseNotesLine(
					original_line="",
					change=commit,
				)
				for commit in commits
			]
			+ [
				# Add an empty line to separate commits from full changelog
				ReleaseNotesLine(
					original_line="",
				)
			]
		)

	def _process_line(self, line: "ReleaseNotesLine"):
		db = get_db(self.db_type, self.db_name) if self.use_db else None

		if not line.change or line.is_new_contributor:
			self.progress.report(ProgressEvent(type="markdown", message=str(line)))
			return

		if line.change.conventional_type in self.exclude_change_types:
			return

		if line.change.labels and line.change.labels & self.exclude_change_labels:
			return

		if db:
			change_id = line.change.get_summary_key()
			stored_sentence = db.get_sentence(self.repository, change_id)
			if stored_sentence:
				line.sentence = stored_sentence
				self.progress.report(ProgressEvent(type="markdown", message=str(line)))
				return

		prompt = line.change.get_prompt(
			prompt_template=self.prompt_path.read_text(),
			max_patch_size=self.max_patch_size,
		)

		change_summary = get_chat_response(
			content=prompt,
			model=self.openai_model,
			api_key=self.openai_api_key,
		)
		if not change_summary:
			return

		change_summary = change_summary.lstrip(" -")
		if db:
			db.store_sentence(self.repository, change_id, change_summary)
		line.sentence = change_summary
		self.progress.report(ProgressEvent(type="markdown", message=str(line)))

	def _get_release(self, tag: str):
		return self.github.get_release(self.repository, tag)


def get_prev_tag(release_notes_body: str, repository: Repository) -> str | None:
	compare_url = f"https://github.com/{repository.owner}/{repository.name}/compare/"
	pos = release_notes_body.find(compare_url)
	if pos != -1:
		return release_notes_body[pos + len(compare_url) :].split("...")[0]

	return None
