import time
from collections.abc import Callable
from functools import partial
from typing import Any

from requests import HTTPError

from .core.config import ReleaseNotesConfig
from .core.execution import ExecutionStrategy, ThreadPoolStrategy
from .core.interfaces import NullProgressReporter, ProgressEvent, ProgressReporter
from .database import get_db
from .github_client import GitHubClient
from .models import ReleaseNotes, ReleaseNotesLine, Repository
from .openai_client import get_chat_response


class ReleaseNotesGenerator:
	def __init__(
		self,
		config: ReleaseNotesConfig,
		progress_reporter: ProgressReporter | None = None,
		execution_strategy: ExecutionStrategy | None = None,
	):
		self.config = config
		self.github = GitHubClient(config.github.token)
		self.repository: Repository | None = None
		self.progress = progress_reporter or NullProgressReporter()
		self.execution = execution_strategy or ThreadPoolStrategy()

		# Store config values for easy access
		self.exclude_change_types = config.filters.exclude_change_types
		self.exclude_change_labels = config.filters.exclude_change_labels
		self.exclude_authors = config.filters.exclude_authors
		self.grouping = config.grouping
		self.openai_api_key = config.openai.api_key
		self.openai_model = config.openai.model
		self.max_patch_size = config.openai.max_patch_size
		self.prompt_path = config.prompt_path
		self.db_type = config.database.type
		self.db_name = config.database.name
		self.use_db = config.database.enabled
		self.force_use_commits = config.force_use_commits

	def initialize_repository(self, owner: str, name: str):
		self.repository = self.github.get_repository(owner, name)

	def generate(self, tag: str, previous_tag_name: str | None = None) -> str:
		"""Generate release notes for a given tag.

		Args:
			tag: Git tag for the release
			previous_tag_name: Optional previous tag to use as starting point
		"""
		assert self.repository is not None, "Repository must be initialized before generating release notes"
		release = self._get_release(tag)
		old_body = release["body"]

		self.progress.report(
			ProgressEvent(
				type="release_notes",
				message=old_body,
				metadata={"heading": "Current Release Notes"},
			)
		)

		if not previous_tag_name:
			previous_tag_name = get_previous_tag_name(old_body, self.repository)

		try:
			gh_notes = self.github.generate_release_notes(self.repository, tag, previous_tag_name)
			new_body = gh_notes["body"]
			self.progress.report(
				ProgressEvent(
					type="release_notes",
					message=new_body,
					metadata={"heading": "Regenerated by GitHub"},
				)
			)
		except HTTPError as e:
			if e.response.status_code not in [403, 404]:
				raise e

			self.progress.report(
				ProgressEvent(
					type="error",
					message="No permission to regenerate release notes, trying to proceed with old ones.",
				)
			)
			new_body = old_body

		self.progress.report(ProgressEvent(type="markdown", message="# Rewriting ..."))

		release_notes = ReleaseNotes.from_string(new_body)
		pr_start_time = time.time()
		self._get_prs_for_lines(release_notes.lines)
		pr_end_time = time.time()
		self.progress.report(
			ProgressEvent(
				type="success",
				message=f"Downloaded PRs in {pr_end_time - pr_start_time:.2f} seconds.",
			)
		)

		if self.force_use_commits or (
			not any(line.change for line in release_notes.lines) and "Full Changelog" in new_body
		):
			release_notes.lines = self._get_commit_lines(tag, previous_tag_name) + release_notes.lines

		process_start_time = time.time()
		self._process_lines(release_notes.lines)
		process_end_time = time.time()
		self.progress.report(
			ProgressEvent(
				type="success",
				message=f"Processed lines in {process_end_time - process_start_time:.2f} seconds.",
			)
		)

		reviewers_start_time = time.time()
		release_notes.load_reviewers()
		reviewers_end_time = time.time()
		self.progress.report(
			ProgressEvent(
				type="success",
				message=f"Loaded reviewers in {reviewers_end_time - reviewers_start_time:.2f} seconds.",
			)
		)

		return release_notes.serialize(
			self.exclude_change_types,
			self.exclude_change_labels,
			self.exclude_authors,
			grouping=self.grouping,
			model_name=f"OpenAI {self.openai_model}",
		)

	def _get_prs_for_lines(self, lines: list["ReleaseNotesLine"]) -> None:
		"""Download info for all PRs in parallel."""
		tasks: list[Callable[[], Any]] = [
			partial(self._get_pr_for_line, line) for line in lines if line.pr_no and not line.is_new_contributor
		]

		if tasks:
			self.execution.execute_parallel(tasks)

	def _get_pr_for_line(self, line: "ReleaseNotesLine"):
		"""Download info for a single PR."""
		assert self.repository is not None, "Repository must be initialized"
		if line.pr_no and not line.is_new_contributor:
			line.change = self.github.get_pr(self.repository, line.pr_no)

	def _process_lines(self, lines: list["ReleaseNotesLine"]) -> None:
		"""Process all lines in parallel."""
		prompt_template = self.prompt_path.read_text()
		tasks: list[Callable[[], Any]] = [partial(self._process_line, line, prompt_template) for line in lines]
		if tasks:
			self.execution.execute_parallel(tasks)

	def update_on_github(self, new_body: str, tag: str):
		"""Update release notes on GitHub."""
		assert self.repository is not None, "Repository must be initialized before updating release notes"
		release = self._get_release(tag)
		try:
			self.github.update_release(self.repository, release["id"], new_body)
			self.progress.report(ProgressEvent(type="success", message="Release notes updated successfully."))
		except HTTPError as e:
			if e.response.status_code != 403:
				raise e

			self.progress.report(
				ProgressEvent(
					type="error",
					message="No permission to update release notes, skipping.",
				)
			)

	def _get_commit_lines(self, tag: str, previous_tag_name: str | None = None):
		assert self.repository is not None, "Repository must be initialized"
		if previous_tag_name:
			commits = self.github.get_diff_commits(self.repository, tag, previous_tag_name)
		else:
			commits = self.github.get_tag_commits(self.repository, tag)

		return (
			[
				# Add the same heading line for the commits, that is automatically added by GitHub for PRs
				ReleaseNotesLine(
					original_line="## What's Changed",
				)
			]
			+ [
				ReleaseNotesLine(
					original_line="",
					change=commit,
				)
				for commit in commits
			]
			+ [
				# Add an empty line to separate commits from full changelog
				ReleaseNotesLine(
					original_line="",
				)
			]
		)

	def _process_line(self, line: "ReleaseNotesLine", prompt_template: str):
		assert self.repository is not None, "Repository must be initialized"
		db = get_db(self.db_type, self.db_name) if self.use_db else None

		if not line.change or line.is_new_contributor:
			self.progress.report(ProgressEvent(type="markdown", message=str(line)))
			return

		if line.change.conventional_type in self.exclude_change_types:
			return

		if line.change.labels and line.change.labels & self.exclude_change_labels:
			return

		if db:
			change_id = line.change.get_summary_key()
			stored_sentence = db.get_sentence(self.repository, change_id)
			if stored_sentence:
				line.sentence = stored_sentence
				self.progress.report(ProgressEvent(type="markdown", message=str(line)))
				return

		prompt = line.change.get_prompt(
			prompt_template=prompt_template,
			max_patch_size=self.max_patch_size,
		)

		try:
			change_summary = get_chat_response(
				content=prompt,
				model=self.openai_model,
				api_key=self.openai_api_key,
			)
		except Exception as e:
			error_msg = f"OpenAI API error for {line.change}: {str(e)}"
			self.progress.report(ProgressEvent(type="error", message=error_msg))
			return

		if not change_summary:
			return

		change_summary = change_summary.lstrip(" -")
		if db:
			db.store_sentence(self.repository, change_id, change_summary)
		line.sentence = change_summary
		self.progress.report(ProgressEvent(type="markdown", message=str(line)))

	def _get_release(self, tag: str):
		assert self.repository is not None, "Repository must be initialized"
		return self.github.get_release(self.repository, tag)


def get_previous_tag_name(release_notes_body: str, repository: Repository) -> str | None:
	compare_url = f"https://github.com/{repository.owner}/{repository.name}/compare/"
	pos = release_notes_body.find(compare_url)
	if pos != -1:
		return release_notes_body[pos + len(compare_url) :].split("...")[0]

	return None
